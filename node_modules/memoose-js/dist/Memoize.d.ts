import { CacheKeyGenerator as CacheKeyGenerator } from "./CacheKeyGenerator";
import { CacheProvider, TTL } from "./adapters/base";
export declare const stats: any;
export type CachedItem = string | {
    data: any;
    reject: boolean;
};
export type MemoizeConfig<Args extends Array<any> = any[], T = any> = {
    functionName?: string;
    argsOrderVain?: boolean;
    cacheProvider?: CacheProvider<CachedItem>;
    cacheKeyGenerator?: CacheKeyGenerator;
    multiExecOverride?: (...argss: Args[]) => Promise<T[]>;
};
export declare class Memoize<Args extends Array<any> = any[], ReturnType = any> {
    private readonly ttl;
    private readonly functionName;
    private readonly argsOrderVain;
    private readonly storeAsObj;
    private func;
    private cacheKeyGenerator;
    private readonly name;
    private readonly multiExecOverride;
    private cache;
    static config: {
        local: boolean;
    };
    /**
     @param func the function who result is to be cached
     @param ttl the time in seconds for which the result is to be cached
     @param options When options.multi is true, the first parameter 'func' in memoize function would refer to the function which will be used to calculate result of a
      key, of which the value does not exists in the cache. options.funcName is to generate the same cacheKeyGenerator that would would generated by cached version of func.
      options.argsOrderVain for when parameters order doesn't matter
     */
    constructor(func: Function, ttl?: number, options?: MemoizeConfig<Args, ReturnType>);
    private isCacheMiss;
    private processedObjFromCache;
    private processObjForCache;
    private pipeline;
    private statsMarkerGenerator;
    cacheKey(this: Memoize<Args, ReturnType>, ...args: Args): string;
    private executeAndCache;
    private saveToCache;
    exec(this: Memoize<Args, ReturnType>, ...args: Args): Promise<ReturnType>;
    call(this: Memoize<Args, ReturnType>, ...args: Args): Promise<ReturnType>;
    update(this: Memoize<Args, ReturnType>, ...argsAndValue: [...Args, ReturnType]): Promise<ReturnType>;
    demoize(this: Memoize<Args, ReturnType>, ...args: Args): Promise<number>;
    refresh(this: Memoize<Args, ReturnType>, ...args: Args): Promise<any>;
    setExp(this: Memoize<Args, ReturnType>, ...argsAndTTL: [...Args, TTL]): Promise<0 | 1>;
    private multiExecuteAndCache;
    private multiSaveToCache;
    multiExec(this: Memoize<Args, ReturnType>, ...argss: Args[]): Promise<ReturnType[]>;
    multiCall(this: Memoize<Args, ReturnType>, ...argss: Args[]): Promise<ReturnType[]>;
}
