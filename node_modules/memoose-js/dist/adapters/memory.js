"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryCacheProvider = void 0;
const timers_1 = require("timers");
class CacheObject {
    constructor(key, data, ttl) {
        this.key = key;
        this.data = data;
        this.ttl = ttl;
    }
}
class MemoryCacheProvider {
    constructor() {
        this.storesAsObj = true;
        this.store = {};
        (0, timers_1.setInterval)(() => {
            for (const key in this.store) {
                if (this.store[key].ttl < Date.now()) {
                    delete this.store[key];
                }
            }
        }, 1000);
    }
    pipeline() {
        throw new Error("Method not implemented.");
    }
    name() {
        return "memory";
    }
    expire(key, new_ttl_from_now) {
        const now = Date.now();
        const object = this.store[key];
        if (!!object && object.ttl > now) {
            object.ttl = now + (new_ttl_from_now * 1000);
            return Promise.resolve(1);
        }
        return Promise.resolve(0);
    }
    del(...keys) {
        keys.forEach(key => delete this.store[key]);
        return Promise.resolve(keys.length);
    }
    set(key, data, ttl) {
        this.store[key] = new CacheObject(key, data, Date.now() + (ttl * 1000));
        return Promise.resolve(data);
    }
    get(key) {
        const object = this.store[key];
        if (!!object) {
            if (object.ttl < Date.now()) {
                return this.del(key).then(_ => null);
            }
            return Promise.resolve(object.data);
        }
        else {
            return Promise.resolve(null);
        }
    }
    dump() {
        return Promise.resolve(this.store);
    }
    flushdb() {
        return this.del(...Object.keys(this.store));
    }
    mget(...keys) {
        return __awaiter(this, void 0, void 0, function* () {
            const now = Date.now();
            return Promise.all(keys.map((obj, index) => __awaiter(this, void 0, void 0, function* () {
                const object = this.store[keys[index]];
                if (!!object) {
                    if (object.ttl < now) {
                        yield this.del(keys[index]);
                        return null;
                    }
                    return object.data;
                }
                else {
                    return null;
                }
            })));
        });
    }
    mset(...kvPairs) {
        return __awaiter(this, void 0, void 0, function* () {
            //hardcoded to 5mins ttl
            kvPairs.forEach(([cachekey, obj]) => this.set(cachekey, obj, 300));
            return "OK";
        });
    }
}
exports.MemoryCacheProvider = MemoryCacheProvider;
