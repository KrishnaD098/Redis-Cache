"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisCacheProvider = void 0;
const ioredis_1 = __importDefault(require("ioredis"));
class RedisCacheProvider {
    name() {
        return "redis";
    }
    constructor(name, options, connect = true) {
        this.storesAsObj = false;
        this.client_client = new ioredis_1.default(options);
        this.connect = connect;
        if (connect)
            this.connected_promise = this.client_client.connect();
        else
            this.connected_promise = Promise.resolve("told not to connect");
        const errorOrCloseCB = (...args) => {
            console.log(`Error in RedisClient: ${name}.`, "\r\n", ...args);
            process.exit(55666);
        };
        this.client_client.on("end", errorOrCloseCB.bind(null, "end"));
        this.client_client.on("error", errorOrCloseCB.bind(null, "error"));
        this.client_client.on("close", errorOrCloseCB.bind(null, "close"));
        this.client_client.on("finish", errorOrCloseCB.bind(null, "finish"));
    }
    getClientConnectionPromise() {
        if (this.connect)
            return this.connected_promise;
        else
            throw new Error("shouldnt call as client initialised with connect=false");
    }
    get(key) {
        return this.client_client.get(key);
    }
    set(key, value, ttl = -1) {
        if (ttl > 0)
            return this.client_client.set(key, value, "EX", ttl);
        else
            return this.client_client.set(key, value);
    }
    del(...keys) {
        return this.client_client.del(...keys);
    }
    awaitTillReady() {
        return new Promise((resolve, reject) => {
            this.client_client.once("ready", resolve);
            this.client_client.once("error", reject);
        });
    }
    get client() {
        return this.client_client;
    }
    pipeline() {
        return this.client_client.pipeline();
    }
    expire(key, ttl) {
        return this.client_client.expire(key, ttl);
    }
    mget(...keys) {
        return this.client_client.mget(...keys);
    }
    mset(...keyValues) {
        return this.client_client.mset(...keyValues);
    }
    exists(...keys) {
        return this.client_client.exists(...keys);
    }
    lpush(key, ...values) {
        return this.client_client.lpush(key, ...values);
    }
    llen(key) {
        return this.client_client.llen(key);
    }
    scard(key) {
        return this.client_client.scard(key);
    }
    sismember(key, member) {
        return this.client_client.sismember(key, member);
    }
    sadd(key, member) {
        return this.client_client.sadd(key, member);
    }
    srem(key, member) {
        return this.client_client.srem(key, member);
    }
    smembers(key) {
        return this.client_client.smembers(key);
    }
    rpush(key, ...values) {
        return this.client_client.rpush(key, ...values);
    }
    lrange(key, start, stop) {
        return this.client_client.lrange(key, start, stop);
    }
    ping() {
        return this.client_client.ping();
    }
    subscribe(...channels) {
        return this.client_client.subscribe(...channels);
    }
    on(event, listener) {
        return this.client_client.on(event, listener);
    }
    publish(channel, message) {
        return this.client_client.publish(channel, message);
    }
    flushdb() {
        return this.client_client.flushdb();
    }
    lpop(key) {
        return this.client_client.lpop(key);
    }
    decrby(key, count) {
        return this.client_client.decrby(key, count);
    }
}
exports.RedisCacheProvider = RedisCacheProvider;
