import IORedis, { Redis, RedisOptions } from "ioredis";
import { CacheKey, CacheProvider } from "./base";
export declare class RedisCacheProvider implements CacheProvider<string> {
    name(): string;
    readonly storesAsObj: boolean;
    private readonly client_client;
    private readonly connected_promise;
    private readonly connect;
    constructor(name: string, options: RedisOptions, connect?: boolean);
    getClientConnectionPromise(): any;
    get(key: string): Promise<string | null>;
    set(key: string, value: string, ttl?: number): Promise<"OK">;
    del(...keys: string[]): Promise<number>;
    awaitTillReady(): Promise<unknown>;
    get client(): Redis;
    pipeline(): any;
    expire(key: string, ttl: number): Promise<0 | 1>;
    mget(...keys: string[]): Promise<(string | null)[]>;
    mset(...keyValues: [CacheKey, string][]): Promise<"OK">;
    exists(...keys: string[]): Promise<number>;
    lpush(key: string, ...values: string[]): Promise<number>;
    llen(key: string): Promise<number>;
    scard(key: string): Promise<number>;
    sismember(key: string, member: string): Promise<number>;
    sadd(key: string, member: any): Promise<number>;
    srem(key: string, member: any): Promise<number>;
    smembers(key: string): Promise<string[]>;
    rpush(key: string, ...values: any[]): Promise<number>;
    lrange(key: string, start: number, stop: number): Promise<string[]>;
    ping(): Promise<"PONG">;
    subscribe(...channels: any[]): Promise<unknown>;
    on(event: string, listener: (...args: any[]) => void): IORedis;
    publish(channel: string, message: string): Promise<number>;
    flushdb(): Promise<"OK">;
    lpop(key: string): Promise<string | null>;
    decrby(key: string, count: number): Promise<number>;
}
