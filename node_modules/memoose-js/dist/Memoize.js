"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Memoize = exports.stats = void 0;
const CacheKeyGenerator_1 = require("./CacheKeyGenerator");
const adapters_1 = require("./adapters");
exports.stats = { redis: {}, memory: {} };
class Memoize {
    /**
     @param func the function who result is to be cached
     @param ttl the time in seconds for which the result is to be cached
     @param options When options.multi is true, the first parameter 'func' in memoize function would refer to the function which will be used to calculate result of a
      key, of which the value does not exists in the cache. options.funcName is to generate the same cacheKeyGenerator that would would generated by cached version of func.
      options.argsOrderVain for when parameters order doesn't matter
     */
    constructor(func, ttl = -1, options = {}) {
        this.statsMarkerGenerator = (start) => (cache_key, isHit) => {
            if (!Memoize.config.local)
                return;
            const time_now = Date.now();
            const time_taken = time_now - start;
            if (isHit)
                exports.stats[this.name][this.functionName].hit = exports.stats[this.name][this.functionName].hit + 1;
            else
                exports.stats[this.name][this.functionName].miss = exports.stats[this.name][this.functionName].miss + 1;
            exports.stats[this.name][this.functionName].total = exports.stats[this.name][this.functionName].total + 1;
            exports.stats[this.name][this.functionName]["adv_stats"][cache_key] = exports.stats[this.name][this.functionName]["adv_stats"][cache_key] || {
                hit: 0,
                miss: 0,
                total: 0,
                history: []
            };
            if (isHit)
                exports.stats[this.name][this.functionName]["adv_stats"][cache_key].hit = exports.stats[this.name][this.functionName]["adv_stats"][cache_key].hit + 1;
            else
                exports.stats[this.name][this.functionName]["adv_stats"][cache_key].miss = exports.stats[this.name][this.functionName]["adv_stats"][cache_key].miss + 1;
            exports.stats[this.name][this.functionName]["adv_stats"][cache_key].total = exports.stats[this.name][this.functionName]["adv_stats"][cache_key].total + 1;
            const last = exports.stats[this.name][this.functionName]["adv_stats"][cache_key].history.pop();
            if (last) {
                exports.stats[this.name][this.functionName]["adv_stats"][cache_key].history.push(last, {
                    time: Date.now(),
                    after: time_now - last.time,
                    type: isHit ? "hit" : "miss",
                    time_taken: time_taken
                });
            }
            else {
                exports.stats[this.name][this.functionName]["adv_stats"][cache_key].history.push({
                    time: Date.now(),
                    after: time_now,
                    type: isHit ? "hit" : "miss",
                    time_taken: time_taken
                });
            }
        };
        this.func = func;
        this.ttl = ttl;
        this.functionName = options.functionName || func.name || "";
        this.argsOrderVain = !!options.argsOrderVain;
        this.multiExecOverride = options.multiExecOverride || (function (...argss) {
            return Promise.all(argss.map(args => func.apply(null, args)));
        });
        this.cacheKeyGenerator = options.cacheKeyGenerator || new CacheKeyGenerator_1.CacheKeyGenerator(this.functionName, this.argsOrderVain);
        this.cache = options.cacheProvider || new adapters_1.MemoryCacheProvider();
        this.storeAsObj = this.cache.storesAsObj;
        this.name = this.cache.name();
        //add chunking for default function if needed
        if (this.functionName === "")
            throw new Error("Anonymous functions can not be memoized. You can pass functionName in options");
        exports.stats[this.name][this.functionName] = exports.stats[this.name][this.functionName] || {
            hit: 0,
            miss: 0,
            total: 0,
            adv_stats: {}
        };
    }
    isCacheMiss(obj) {
        return obj === null || obj === undefined;
    }
    processedObjFromCache(obj) {
        function processStr(obj) {
            if (obj.indexOf('-undefined-') === 0)
                return undefined;
            if (obj.indexOf('-null-') === 0)
                return null;
            return JSON.parse(obj);
        }
        if (this.storeAsObj && !isString(obj))
            return obj.reject ? Promise.reject(obj.data) : Promise.resolve(obj.data);
        if (!isString(obj))
            throw new Error("stored as string but got obj from cache?");
        if (obj.indexOf('-reject-') === 0)
            return Promise.reject(processStr(obj.substr('-reject-'.length)));
        else
            return Promise.resolve(processStr(obj));
    }
    processObjForCache(obj, rejection = false) {
        if (this.storeAsObj) {
            return { data: obj, reject: rejection };
        }
        else {
            let resp_val = JSON.stringify(obj);
            if (resp_val === undefined)
                resp_val = '-undefined-';
            if (resp_val === null)
                resp_val = '-null-';
            if (rejection)
                resp_val = `-reject-${resp_val}`;
            return resp_val;
        }
    }
    pipeline() {
        return this.cache.pipeline();
    }
    ;
    //public
    cacheKey(...args) {
        return this.cacheKeyGenerator.for(...args);
    }
    ;
    //function single call
    executeAndCache(cache_key, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let resp = yield this.exec(...args);
                this.saveToCache(resp, cache_key, this.ttl);
                return resp;
            }
            catch (eResp) {
                this.saveToCache(eResp, cache_key, this.ttl, true);
                return Promise.reject(eResp);
            }
        });
    }
    saveToCache(resp_val_original, cache_key, ttl, rejection = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (ttl <= 0)
                ttl = -1;
            const resp_val = this.processObjForCache(resp_val_original, rejection);
            yield this.cache.set(cache_key, resp_val, ttl)
                .catch(console.error.bind(null, cache_key, resp_val));
        });
    }
    ;
    exec(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.func.apply(null, args);
        });
    }
    ;
    call(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            const cache_key = this.cacheKeyGenerator.for(...args);
            const statsMarker = this.statsMarkerGenerator(Date.now());
            let isHit = true;
            const obj = yield this.cache.get(cache_key);
            if (this.isCacheMiss(obj)) {
                isHit = false;
                return this.executeAndCache(cache_key, ...args);
            }
            statsMarker(cache_key, isHit);
            return this.processedObjFromCache(obj);
        });
    }
    ;
    update(...argsAndValue) {
        return __awaiter(this, void 0, void 0, function* () {
            let newValue = argsAndValue.pop();
            let args = argsAndValue;
            const cache_key = this.cacheKeyGenerator.for(...args);
            let item = this.processObjForCache(newValue);
            yield this.cache.set(cache_key, item, this.ttl);
            return newValue;
        });
    }
    ;
    demoize(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            const cache_key = this.cacheKeyGenerator.for(...args);
            return this.cache.del(cache_key);
        });
    }
    ;
    refresh(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            //doesnt refresh if it doesnt exist in cache
            const cache_key = this.cacheKey(...args);
            const didDelete = yield this.cache.del(cache_key);
            if (didDelete)
                yield this.executeAndCache(cache_key, ...args);
            return Promise.resolve();
        });
    }
    ;
    setExp(...argsAndTTL) {
        return __awaiter(this, void 0, void 0, function* () {
            let newTTL = argsAndTTL.pop();
            let args = argsAndTTL;
            const cache_key = this.cacheKey(...args);
            return this.cache.expire(cache_key, newTTL);
        });
    }
    ;
    //function multi call
    multiExecuteAndCache(...cache_key_and_args_s) {
        return __awaiter(this, void 0, void 0, function* () {
            const argssToExec = cache_key_and_args_s.map(([cacheKey, args]) => args);
            const newRespGen = yield this.multiExec(...argssToExec);
            const argsToSaveToCache = [];
            for (let i = 0; i < cache_key_and_args_s.length; i++) {
                const [cacheKey, args] = cache_key_and_args_s[i];
                const resp = yield newRespGen[i];
                argsToSaveToCache.push([resp, cacheKey, this.ttl, false]);
            }
            this.multiSaveToCache(...argsToSaveToCache);
            return newRespGen;
        });
    }
    multiSaveToCache(...argss) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!argss.length)
                return;
            const toCache = [];
            for (let i = 0; i < argss.length; i++) {
                let [resp_val_original, cache_key, ttl, rejection] = argss[i];
                if (ttl <= 0)
                    ttl = -1;
                toCache.push([cache_key, this.processObjForCache(resp_val_original, rejection)]);
            }
            yield this.cache.mset(...toCache);
        });
    }
    multiExec(...argss) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.multiExecOverride.apply(null, argss);
        });
    }
    ;
    multiCall(...argss) {
        return __awaiter(this, void 0, void 0, function* () {
            if (argss.length === 0)
                return Promise.resolve([]);
            const cacheKeys = argss.map((args) => this.cacheKeyGenerator.for(...args));
            const statsMarker = this.statsMarkerGenerator(Date.now());
            const redisHits = yield this.cache.mget(...cacheKeys);
            const misses = [];
            const hits = [];
            for (let i = 0; i < redisHits.length; i++) {
                const obj = redisHits[i];
                let isHit = true;
                if (obj === null || obj === undefined) {
                    isHit = false;
                    misses.push([i, [cacheKeys[i], argss[i]]]);
                }
                else {
                    hits.push([i, [cacheKeys[i], argss[i]], yield this.processedObjFromCache(obj)]);
                }
                statsMarker(cacheKeys[i], isHit);
            }
            const arggsToExecAndCache = misses.map(([idx, [cache_key, args]]) => [cache_key, args]);
            const newResps = yield this.multiExecuteAndCache(...arggsToExecAndCache);
            if (misses.length !== newResps.length)
                throw new Error(`misses:${misses.length} !== newResps:${newResps.length}`);
            for (let i = 0; i < misses.length; i++) {
                const resp = newResps[i];
                const [idx, [cache_key, args]] = misses[i];
                hits.push([idx, [cache_key, args], resp]);
            }
            hits.sort((hit1, hit2) => hit1[0] > hit2[0] ? 1 : -1);
            return hits.map(hit => hit[2]);
        });
    }
}
Memoize.config = {
    local: true,
};
exports.Memoize = Memoize;
function isString(input) {
    return typeof input === "string";
}
